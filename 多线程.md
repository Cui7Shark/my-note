# C语言中的线程

## 1. 进程和线程

1. 进程是资源分配的最小单位，线程是操作系统调度执行的最小单位。

2. 进程和线程的区别：

   - 进程有自己独立的地址空间，多个线程共用同一个地址空间。

     - 在一个地址空间中，多个线程独享：栈区，寄存器。

     - 在一个地址空间中，多个线程共享：代码区，堆区，全局数据区，打开的文件。

   - 线程是程序的最小执行单元，进程是最小的资源分配单位。

   - CPU的调度和切换：线程的上下文切换比进程要快的多。

   - 线程更加廉价，启动速度快，退出快，对系统资源的冲击小。

## 2. 创建线程

```c++
phread_t phread_self(void); //线程函数，返回当前线程的ID
```

```c
#include <pthread.h>
int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
                   void *(*start_routine) (void *), void *arg);
// Compile and link with -pthread, 线程库的名字叫pthread, 全名: libpthread.so libptread.a
```

- 虚拟地址空间的生命周期和主线程是一样的，与子线程无关。
- sleep（）：可以让主线程挂起，让子线程执行完毕，主线程再退出。

## 3. 线程退出

```c++
#include<pthread.h>
void phtread_eixt(void *retval);//只要调用该函数当前线程就马上退出了，并且不会影响到其他线程的正常运行，不管是在子线程或者主线程中都可以使用。
//主线程调用退出函数退出, 地址空间不会被释放
```

## 4. 线程回收

> 子线程退出的时候其内核资源主要由主线程回收，线程库中提供的线程回收函叫做``` pthread_join()```，这个函数是一个阻塞函数，如果还有子线程在运行，调用该函数就会阻塞，子线程退出函数解除阻塞进行资源的回收，函数被调用一次，只能回收一个子线程，如果有多个子线程则需要循环进行回收。

### 4.1 回收子线程数据

- 使用子线程栈 ：

  ```c++
  pthread_exit(&p); //子线程退出
  pthread_join(tid, &ptr); //主线程回收子线程资源，通过ptr void*类型指针传出子线程数据。
  ```

  

- 使用全局变量

  - 位于同一虚拟地址空间中的线程，虽然不能共享栈区数据，但是**可以共享全局数据区和堆区数据**，因此在子线程退出的时候可以将**传出数据存储到全局变量、静态变量或者堆内存**中。

- 使用主线程栈

## 5. 线程分离

```c++
#include <pthread.h>
// 参数就子线程的线程ID, 主线程就可以和这个子线程分离了
int pthread_detach(pthread_t thread);
```

- 调用这个函数之后指定的子线程就可以和主线程分离，当子线程退出的时候，其占用的内核资源就被系统的其他进程接管并回收了。线程分离之后在主线程中使用 ```pthread_join()``` 就回收不到子线程资源了。

- 为何使用线程分离：因为主线程有自己的业务处理流程，如果让主线程负责子线程的资源回收，调用``` pthread_join()``` 只要子线程不退出主线程就会一直被阻塞，主要线程的任务也就不能被执行了。

## 6. 其他线程函数

- 线程取消

  ```c
  #include<pthread.h>
  int pthread_cancel(pthread_t, thread);
  ```

  > 使用这个函数杀死一个线程需要分两步：
  >
  > 在线程 A 中调用线程取消函数 `pthread_cancel`，指定杀死线程 B，这时候线程 B 是死不了的
  > 在线程 B 中进程一次系统调用（从用户区切换到内核区），否则线程 B 可以一直运行。

- 线程ID比较

  - 在 Linux 中线程 ID 本质就是一个无符号长整形，在某些平台上 pthread_t 可能不是一个单纯的整形，这中情况下比较两个线程的 ID 必须要使用比较函数，函数原型如下

    ```c
    #include <pthread.h>
    int pthread_equal(pthread_t t1, pthread_t t2);
    ```

    >参数：t1 和 t2 是要比较的线程的线程 ID
    >返回值：如果两个线程 ID 相等返回非 0 值，如果不相等返回 0

